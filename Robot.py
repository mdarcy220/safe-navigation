import numpy  as np
import pygame as PG
import math
from Radar import Radar
import Distributions
import Vector
import matplotlib.pyplot as plt
import time
import scipy.signal


## Holds statistics about the robot's progress, used for reporting the
# results of the simulation.
#
class RobotStats:
	def __init__(self):
		self.num_glitches = 0
		self.num_steps = 0


## Represents a robot attempting to navigate safely through the
# environment.
#
class Robot:
	## Constructor
	#
	# @param target (numpy array)
	# <br>	Format: `[x, y]`
	# <br>	-- The target point that the robot is trying to reach
	#
	# @param initial_position (numpy array)
	# <br>	Format: `[x, y]`
	# <br>	-- The initial position of the robot
	#
	# @param radar (`Radar` object)
	# <br>	-- A radar for the robot to use to observe the environment
	#
	# @param speed (float)
	# <br>	-- The speed of the robot
	#
	# @param cmdargs (object)
	# <br>	-- A command-line arguments object generated by `argparse`.
	#
	# @param using_safe_mode (boolean)
	# <br>	-- Whether the robot should operate in "safe mode", which
	# 	slightly changes the way the navigation algorithm works.
	#
	# @param name (string)
	# <br>	-- A name for the robot, only used for the purpose of
	# 	printing debugging messages.
	#
	def __init__(self, target, initial_position, radar, speed = 6, cmdargs=None, using_safe_mode = False, name=""):
		self._cmdargs		= cmdargs
		self.target		= target
		self.location		= initial_position
		self.speed		= speed
		self.stats		= RobotStats()
		self.name		= name
		self.using_safe_mode	= using_safe_mode
		self._drawcoll = 0

		self.normal_speed		= speed
		self.max_speed			= 10
		if (self._cmdargs.speedmode == 5):
			self.normal_speed = 10
		if (not self.using_safe_mode):
			self.normal_speed = 10
		
		self.speed = self.normal_speed

		self._speed_adjust_pdf = Distributions.Gaussian()
		self._speed_adjust_pdf.degree_resolution = 2
		

		self.radar	= radar
		self.PathList	= []
		self._PDF	= Distributions.Gaussian()
		if (self._cmdargs.target_distribution_type == 'rectangular'):
			self._PDF = Distributions.Rectangular()
		# Function that selects an angle based on a distribution
		self._pdf_angle_selector = self.center_of_gravity_pdfselector
		# Function that combines pdfs
		self._combine_pdfs	= np.minimum

		# Memory of visited points
		self.visited_points	= []
		# Stores the memory and movement vectors (for drawing in debug mode)
		self._drawing_pdf        = None
		self._last_mbv		= np.array([0, 0])
		self._last_mmv		= np.array([0, 0])

		# Movement and memory parameters
		self.movement_momentum	= 0
		self.memory_sigma 	= 25
		self.memory_decay 	= 1
		self.memory_size  	= 500
		if (not (cmdargs is None)):
			self.movement_momentum = cmdargs.robot_movement_momentum
			self.memory_sigma = cmdargs.robot_memory_sigma
			self.memory_decay = cmdargs.robot_memory_decay
			self.memory_size  = cmdargs.robot_memory_size

		# Number of decision steps taken in the navigation
		self.stepNum			= 0

		self._last_glitch_step	= -1

		# Used to allow real-time plotting
		if (not (cmdargs is None)) and (cmdargs.show_real_time_plot):
			plt.ion()
			plt.show()

	def get_stats(self):
		return self.stats


	def SetSpeed(self, speed):
		self.speed = speed


	## Creates an array for adding noise to a distribution
	#
	# @param noise_level (float)
	# <br>	-- The amplitude of the noise
	#
	# @param size (int)
	# <br>	-- The size of the array to generate
	#
	# @returns (numpy array)
	# <br>	-- An array of noise values, that can be added to a
	# 	distribution to make it noisy.
	def gaussian_noise(self, noise_level, size):
		noise_pdf = np.random.normal(0, noise_level, size)
		return noise_pdf


	## Does one step of the robot's navigation.
	#
	# This function uses radar and location information to make a
	# decision about the robot's next action to reach the goal. Then,
	# it takes one step in the planned direction.
	#
	def NextStep(self, grid_data):
		# Variable naming note: some variables have _pdf on their
		# name, which is meant to indicate that they represent some
		# kind of probability distribution over the possible
		# movement directions

		self.stepNum += 1
		self.stats.num_steps += 1

		# The targetpoint PDF relates to the target/goal. It should
		# be higher for angles that point towards the goal, and
		# lower for angles that point away
		targetpoint_pdf = self._PDF.get_distribution(self.angleToTarget())
		if (self._cmdargs.target_distribution_type == 'dotproduct'):
			targetpoint_ang = self.angleToTarget()
			targetpoint_pdf = np.array([(self.speed*(np.cos(np.abs(targetpoint_ang - ang) * np.pi/180)+1)/2) for ang in np.arange(0, 360, self._PDF.degree_resolution)], dtype='float64')
			targetpoint_pdf = (targetpoint_pdf / np.amax(targetpoint_pdf)) * 0.8 + 0.2

		# The combined PDF will store the combination of all the
		# PDFs, but for now that's just the targetpoint PDF
		self._combined_pdf = targetpoint_pdf

		# Scan the radar to get obstacle information. This
		# radar_data variable could just as well be named
		# obstacle_pdf, because that's what it represents.
		radar_data = self.radar.ScanRadar(self.location, grid_data)
		if (0 < self._cmdargs.radar_noise_level):
			radar_data += self.gaussian_noise(self._cmdargs.radar_noise_level, radar_data.size)

		# Add the obstacle distribution into the combined PDF
		self._combined_pdf = self._combine_pdfs(self._combined_pdf, radar_data)

		# Process memory
		if (not (self._cmdargs is None)) and (self._cmdargs.enable_memory):
			# Get memory effect vector
			mem_bias_vec = self.calc_memory_bias_vector()
			self._last_mbv = mem_bias_vec

			mem_bias_ang = Vector.getAngleBetweenPoints((0,0), mem_bias_vec)
			mem_bias_mag = Vector.getDistanceBetweenPoints((0,0), mem_bias_vec)

			# Create memory distribution based on dot product with memory vector
			mem_bias_pdf = np.array([np.cos(np.abs(mem_bias_ang - ang) * np.pi/180) for ang in np.arange(0, 360, self._PDF.degree_resolution)])
			mem_bias_pdf += 1 # Add 1 to get the cosine function above 0
			if np.amax(mem_bias_pdf) > 0:
				mem_bias_pdf = mem_bias_pdf / np.amax(mem_bias_pdf)

			# Add the memory distribution to the combined PDF
			self._combined_pdf = self._combine_pdfs(self._combined_pdf, mem_bias_pdf)

			if (self.stepNum % 1) == 0:
				self.visited_points.append(self.location)

		# Possibly smooth the combined distribution, to avoid
		# having sudden jumps in value
		if (self._cmdargs.enable_pdf_smoothing_filter):
			self._combined_pdf = self._putfilter(self._combined_pdf)

		self._combined_pdf = np.maximum(self._combined_pdf, 0);
		movement_ang = self._pdf_angle_selector(self._combined_pdf) * self._PDF.degree_resolution

		# Adjust the speed if safe mode is enabled
		if (self.using_safe_mode):
			dynamic_pdf = self.radar.scan_dynamic_obstacles(self.location, grid_data)
			#self._drawing_pdf = dynamic_pdf
			self._adjust_speed_for_safety(dynamic_pdf, movement_ang)

		if (self._cmdargs.show_real_time_plot):
			plt.cla()
			plt.plot(self._combined_pdf)
			plt.plot(targetpoint_pdf)
			plt.plot(mem_bias_pdf)
			plt.plot(radar_data)
			plt.axis([0,360,0,1.1])
			plt.pause(0.00001)

		# Update the robot's motion based on the chosen direction
		# (uses acceleration to prevent the robot from being able
		# to instantaneously change direction, more realistic)
		accel_vec = np.array([np.cos(movement_ang * np.pi / 180), np.sin(movement_ang * np.pi / 180)], dtype='float64') * self.speed
		movement_vec = np.add(self._last_mmv * self.movement_momentum, accel_vec * (1.0 - self.movement_momentum))
		if Vector.magnitudeOf(movement_vec) > self.speed:
			movement_vec *= self.speed / Vector.magnitudeOf(movement_vec) # Set length equal to self.speed
		self._last_mmv = movement_vec

		# Update the robot's position and check for a collision
		# with an obstacle
		new_location = np.add(self.location, movement_vec)
		if (grid_data[int(new_location[0]), int(new_location[1])] & 1):
			if self.stepNum - self._last_glitch_step > 1:
				if not self._cmdargs.batch_mode:
					print('Robot ({}) glitched into obstacle!'.format(self.name))
				self._drawcoll = 10
				self.stats.num_glitches += 1
			self._last_glitch_step = self.stepNum
			new_location = np.add(new_location, -movement_vec*1.01 + np.random.uniform(-.5, .5, size=2));
			if(Vector.getDistanceBetweenPoints(self.location, new_location) > 2*self.speed):
				new_location = np.add(self.location, np.random.uniform(-0.5, 0.5, size=2))

		if (self._cmdargs.use_integer_robot_location):
			new_location = np.array(new_location, dtype=int)
		self.location = new_location

		self.PathList.append(np.array(self.location, dtype=int))


	## Smooths the given distribution
	#
	def _putfilter(self, inputsignal):
		N = 10 #order of the butterworth  filter
		Wn = 0.1 #Nyquest Sampling frequency
		b, a = scipy.signal.butter(N, Wn, 'low') #create butterworth filter
		outputsignal = scipy.signal.filtfilt(b, a, inputsignal)
		return outputsignal


	## Adjusts the speed of the robot based on the given dynamic obstacle 
	# distribution and movement angle
	def _adjust_speed_for_safety(self, dynamic_pdf, movement_ang):
		closest_obs_degree	 = np.argmin (dynamic_pdf)
		closest_obs_dist = np.min(dynamic_pdf)
		angle_from_movement = np.absolute(Vector.angle_diff_degrees(movement_ang, closest_obs_degree))

		angle_weight_pdf = self._speed_adjust_pdf.get_distribution(90)

		self.speed = self.normal_speed
		min_speed = 2
		max_speed = 10
		speed_range = 2*(max_speed - min_speed)

		front_pdf = 1 - dynamic_pdf.take(np.arange(-90, 90, 1), mode='wrap')
		front_pdf[front_pdf > 0.05] = 1
		front_pdf *= angle_weight_pdf
		front_obs_ratio = front_pdf.sum() / front_pdf.size

		back_pdf = 1- dynamic_pdf.take(np.arange(90, 270, 1), mode='wrap')
		back_pdf[back_pdf > 0.05] = 1
		back_pdf *= angle_weight_pdf
		back_obs_ratio = back_pdf.sum() / back_pdf.size

		self.speed = self.normal_speed + (1.25*back_obs_ratio - front_obs_ratio) * (speed_range / 2.0)
		self.speed = np.clip(self.speed, min_speed, max_speed)


	def center_of_gravity_pdfselector(self, pdf):
		width = 60
		maxval_ind = np.argmax(pdf)
		sum_num = 0
		sum_den = 0
		for n in np.arange(int(maxval_ind - width / 2), int(maxval_ind + width/2), 1):
			sum_num += pdf[n % 360] * n
			sum_den += pdf[n % 360]
		center_of_mass = int(sum_num / (sum_den + 0.00001)) # Add a small number (0.00001) in case sum_den is 0
		return center_of_mass % 360


	def threshold_midpoint_pdfselector(self, pdf):
		maxval_ind = np.argmax(pdf)
		maxval = pdf[maxval_ind]
		threshold = 0.8 * maxval
		runStart = 0
		runLen = 0
		runPos = 0
		bestLen = 0
		bestStart = maxval_ind
		while runPos < len(pdf):
			if threshold <= pdf[runPos]:
				runLen += 1
			else:
				if bestLen < runLen:
					bestStart = runStart
					bestLen = runLen
				runStart = runPos
				runLen = 0
			runPos += 1
		return bestStart+int(bestLen/2)


	def max_value_pdfselector(self, pdf):
		return np.argmax(pdf)


	def calc_memory_bias_vector(self):
		sigma = self.memory_sigma
		decay = self.memory_decay
		size = int(self.memory_size)
		sigmaSquared = sigma * sigma
		gaussian_derivative = lambda x: -x*(np.exp(-(x*x/(2*sigmaSquared))) / sigmaSquared)
		vec = np.array([0, 0], dtype='float64')
		i = size
		for point in self.visited_points[-size:]:
		#for point in [PG.mouse.get_pos()]:
			effect_magnitude = gaussian_derivative(Vector.getDistanceBetweenPoints(point, self.location))
			effect_vector = (decay**i) * effect_magnitude * np.subtract(point, self.location)
			vec += effect_vector
			i -= 1
		return vec


	## Draws this `Robot` to the given surface
	#
	# @param screen (`pygame.Surface` object)
	# <br>	-- The surface on which to draw the robot
	#
	def draw(self, screen):
		#PG.draw.circle(screen, (0, 0, 255), np.array(self.location, dtype=int), 4, 0)
		BlueColor  = (0, 0, 255)
		GreenColor = (10, 100, 10)
		if (self.using_safe_mode):
			PathColor = GreenColor
		else:
			PathColor = BlueColor
		for ind, o in enumerate(self.PathList):
			if ind == len(self.PathList) - 1:
				continue
			PG.draw.line(screen,PathColor,self.PathList[ind], self.PathList[ind +1], 2)
		if (0 < self._cmdargs.debug_level):
			if self._drawcoll > 0:
				PG.draw.circle(screen, (255, 127, 127), np.array(self.location, dtype=int), 15, 1)
				self._drawcoll = self._drawcoll - 1
			# Draw line representing memory effect
			#PG.draw.line(screen, (0,255,0), np.array(self.location, dtype=int), np.array(self.location+self._last_mbv*100, dtype=int), 1)

			# Draw line representing movement
			#PG.draw.line(screen, (255,0,0), np.array(self.location, dtype=int), np.array(self.location+self._last_mmv*100, dtype=int), 1)

			# Draw circle representing radar range
			PG.draw.circle(screen, PathColor, np.array(self.location, dtype=int), self.radar.radius, 2)

			# Draw distribution values around robot
			#self._draw_pdf(screen, self._drawing_pdf)


	def _draw_pdf(self, screen, pdf):
		if pdf is None:
			return;
		scale = self.radar.radius
		last_point = [self.location[0] + (pdf[0] * scale), self.location[1]]
		for index in np.arange(0, len(pdf), 1):
			ang = index * self._PDF.degree_resolution * np.pi / 180
			cur_point = self.location + scale*pdf[index]*np.array([np.cos(ang), np.sin(ang)], dtype='float64')
			PG.draw.line(screen, (0,200,200), last_point, cur_point, 1)
			last_point = cur_point


	def distanceToTarget(self):
		return Vector.getDistanceBetweenPoints(self.target.position, self.location)

	def angleToTarget(self):
		return Vector.getAngleBetweenPoints(self.location, self.target.position)

	def get_location(self):
		return self.location;
