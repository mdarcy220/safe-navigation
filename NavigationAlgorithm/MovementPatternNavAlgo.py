#!/usr/bin/python3

from Robot import RobotControlInput
from .AbstractNavAlgo import AbstractNavigationAlgorithm
import numpy as np
import MovementPattern

## A nav algo that attempts to follow the given MovementPattern.
# 
# Note that if the Robot cannot move as quickly as the MovementPattern demands,
# the behavior is undefined.
#
class MovementPatternNavigationAlgorithm(AbstractNavigationAlgorithm):

	## Initializes the navigation algorithm.
	# 
	# @param sensors (dict of sensors)
	# <br>	-- the sensors that this algorithm has access to
	#
	# @param target (Target obj)
	# <br>	-- the target for the navigation
	#
	# @param cmdargs (object)
	# <br>	-- A command-line arguments object generated by `argparse`.
	#
	# @param movement (MovementPattern object)
	# <br>	-- The MovementPattern to follow
	# 
	def __init__(self, sensors, target, cmdargs, movement):
		self._sensors = sensors;
		self._target  = target;
		self._cmdargs = cmdargs;
		self._movement = movement

		self._gps = self._sensors['gps'];
		self._radar = self._sensors['radar'];

		self.debug_info = {'min_proximities': []};


	## Select the next action for the robot
	#
	# This function uses the robot's radar and location information, as
	# well as internally stored information about previous locations,
	# to compute the next action the robot should take.
	#
	# @returns (`Robot.RobotControlInput` object)
	# <br>	-- A control input representing the next action the robot
	# 	should take.
	#
	def select_next_action(self):
		radar_data = self._radar.scan(self._gps.location())
		self.debug_info['min_proximities'].append(np.min(radar_data))

		self._movement.step(1)
		next_pos = self._movement.get_pos()
		direction = self._gps.angle_to(next_pos)
		speed = self._gps.distance_to(next_pos)
		
		return RobotControlInput(speed, direction);


	def has_given_up(self):
		return False;


