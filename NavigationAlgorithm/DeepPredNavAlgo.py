#!/usr/bin/python3

from Robot import RobotControlInput
from .AbstractNavAlgo import AbstractNavigationAlgorithm

import cntk as C
import numpy as np
import Vector
import sys

## A navigation algorithm based on an RNN that predicts the next action.
#
class DeepPredNavigationAlgorithm(AbstractNavigationAlgorithm):

	## Initializes the navigation algorithm.
	# 
	# @param sensors (dict of sensors)
	# <br>	-- the sensors that this algorithm has access to
	#
	# @param target (Target obj)
	# <br>	-- the target for the navigation
	#
	# @param cmdargs (object)
	# <br>	-- A command-line arguments object generated by `argparse`.
	# 
	def __init__(self, sensors, target, cmdargs, net_type = 'perl', net_load_file=''):
		self._sensors = sensors;
		self._target  = target;
		self._cmdargs = cmdargs;
		self._net_type = net_type
		self._net_load_file = net_load_file

		if net_load_file == '':
			if net_type == 'perl':
				self._net_load_file = './human_action/dnns/action_predicter.dnn'
			else:
				self._net_load_file = './human_action/dnns/GRP.dnn'

		C.logging.set_trace_level(C.logging.TraceLevel.Error)

		self._gps = self._sensors['gps'];
		self._radar = self._sensors['radar'];

		if net_type == 'perl':
			feature_vector, target_vector, action_vector, velocity = (2,360), (1,361), (1,360), (1,1)
			self._input_size    = feature_vector
			self._output_size   = action_vector
			self._target_size   = target_vector
			self._velocity_size = velocity
			self._input           = C.sequence.input_variable(self._input_size)
			self._target_inputvar = C.sequence.input_variable(self._target_size)
			self._output          = C.sequence.input_variable(self._output_size)
			self._output_velocity = C.sequence.input_variable(self._velocity_size)

			self._model = self._create_perl_model()
		elif net_type == 'grp':
			feature_vector, target_features, action_vector, velocity = (2,360), (1,361), (1,360), (1,1)
			self._input_size    = feature_vector
			self._output_size   = action_vector
			self._velocity_size = velocity
			self._input           = C.input_variable(self._input_size)
			self._target_input    = C.input_variable(target_features)
			self._output          = C.input_variable(self._output_size)
			self._output_velocity = C.input_variable(self._velocity_size)

			self._model = self._create_grp_model()
		else:
			print('ERROR: Unknown net type', file=sys.stderr)

		self._start_pos = np.copy(self._gps.location())

		self._last_radar_data = self._radar.scan(self._gps.location())

		self.debug_info = {'min_proximities': []};


	## Select the next action for the robot
	#
	# This function uses the robot's radar and location information, as
	# well as internally stored information about previous locations,
	# to compute the next action the robot should take.
	#
	# @returns (`Robot.RobotControlInput` object)
	# <br>	-- A control input representing the next action the robot
	# 	should take.
	#
	def select_next_action(self):

		predicted_values = None
		if self._net_type == 'perl':
			input_dict = self._create_perl_input_data()
			predicted_values = self._model.eval((input_dict, [True if Vector.distance_between(self._gps.location(), self._start_pos) < 0.01 else False]))[0][0]
		else:
			input_dict = self._create_grp_input_data()
			predicted_values = self._model.eval(input_dict)[0]

		direction = np.argmax(predicted_values[0:360])*360/359
		speed = predicted_values[360]
		#print(self._gps.location(), direction, speed, True if Vector.distance_between(self._gps.location(), self._start_pos) < 0.01 else False)
		return RobotControlInput(speed, direction);


	def _get_target_direction_input_data(self):
		target_vec    = np.subtract(self._target.position, self._gps.location())
		target_angle  = np.arctan2(target_vec[1], target_vec[0])
		target_angle  = target_angle * 180 / np.pi
		target_angle  = (target_angle+360) % 360
		target_action = np.zeros((1,360), dtype=np.float32)
		target_angle  = int(round(target_angle*359/360))
		target_action[0,target_angle] = 1
		return target_action


	def has_given_up(self):
		return False;


	def _create_perl_input_data(self):
		radar_data = self._radar.scan(self._gps.location())
		self.debug_info['min_proximities'].append(np.min(radar_data))

		radar_input_data = np.stack((self._last_radar_data, radar_data), axis=0)
		radar_input_data = np.expand_dims(radar_input_data, 0).astype(np.float32)

		#target_radar_data = self._radar.scan(self._target.position)
		target_radar_data = np.zeros((1,361), dtype=np.float32)
		target_radar_data[0][int(round(self._gps.angle_to(self._target.position)*359/360))] = 1
		target_radar_data[0][360] = self._gps.distance_to(self._target.position)/3

		#radar_input_data = np.expand_dims(radar_data, 0).astype(np.float32)
		target_radar_input_data = np.expand_dims(target_radar_data, 0).astype(np.float32)

		input_dict = {
			self._model.arguments[0]: [radar_input_data], 
			self._model.arguments[1]: [target_radar_input_data],
		}
		self._last_radar_data = radar_data
		return input_dict


	def _create_grp_input_data(self):
		radar_data = self._radar.scan(self._gps.location())
		self.debug_info['min_proximities'].append(np.min(radar_data))

		radar_input_data = np.stack((self._last_radar_data, radar_data), axis=0)
		radar_input_data = np.expand_dims(radar_input_data, 0).astype(np.float32)

		#target_radar_data = self._radar.scan(self._target.position)
		target_radar_data = np.zeros((1,361), dtype=np.float32)
		target_radar_data[0][int(round(self._gps.angle_to(self._target.position)*359/360))] = 1
		target_radar_data[0][360] = self._gps.distance_to(self._target.position)/3

		#radar_input_data = np.expand_dims(radar_data, 0).astype(np.float32)
		target_radar_input_data = np.expand_dims(target_radar_data, 0).astype(np.float32)

		input_dict = {
			self._model.arguments[0]: radar_input_data, 
			self._model.arguments[1]: target_radar_input_data,
		}
		self._last_radar_data = radar_data
		return input_dict


	## Copied from direction_predictor/complete_model.py
	#
	def _create_perl_model(self):
		action_model = C.load_model(self._net_load_file)(self._input, self._target_inputvar)
		action_model = action_model.clone(C.CloneMethod.freeze)

		return action_model


	## Copied from GRP/complete_model.py
	#
	def _create_grp_model(self):
		action_model = C.load_model(self._net_load_file)(self._input, self._target_input)
		action_model = action_model.clone(C.CloneMethod.freeze)

		return action_model
