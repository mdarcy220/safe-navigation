#!/usr/bin/python3

import numpy	as np
import Vector, time
from math import *
from .AbstractNavAlgo import AbstractNavigationAlgorithm
from Robot import RobotControlInput

class IntegratedEnvNavigationAlgorithm(AbstractNavigationAlgorithm):

	## Initializes the navigation algorithm.
	# 
	# @param sensors (dict of sensors)
	# <br>	-- the sensors that this algorithm has access to
	#
	# @param target (Target obj)
	# <br>	-- the target for the navigation
	#
	# @param cmdargs (object)
	# <br>	-- A command-line arguments object generated by `argparse`.
	# 
	def __init__(self, sensors, target, cmdargs):
		self._sensors = sensors;
		self._target  = target;
		self._cmdargs = cmdargs;

		self._radar = sensors['radar'];
		self._gps = sensors['gps'];

		self.debug_info = {};

		self._range_limit = self._radar.radius/1.2;
		self._heading = self._gps.angle_to(self._target.position);


	## Next action selector method.
	#
	# @see 
	# \ref AbstractNavAlgo.AbstractNavigationAlgorithm.select_next_action
	#		"AbstractNavigationAlgorithm.select_next_action()"
	#
	def select_next_action(self):
		radar_data = self._radar.scan(self._gps.location());
		radar_data_size = len(radar_data)
#		self._range_limit = np.max(radar_data)/1.2;
		target_angle = self._gps.angle_to(self._target.position)
		intervals = self._split_radar_to_intervals(radar_data);
		self.debug_info['intervals'] = intervals;

		direction = self._gps.angle_to(self._target.position);
		if(not np.all(radar_data >= self._range_limit/1.05)):
			tmp_heading = self._heading + (self._gps.angle_to(self._target.position) - self._heading)*0.00
			chosen_interval = self._get_closest_interval(intervals, self._heading);
			direction = ((chosen_interval[0] + chosen_interval[1]) / 2 - self._heading) * 1 + self._heading
		self._heading = direction;
		speed = self._range_limit; # Go as fast as possible without leaving the observable zone
		return RobotControlInput(speed, direction);


	def _split_radar_to_intervals(self, radar_data):
		truth_arr = radar_data > self._range_limit;
		seq_arr = np.r_[True, np.diff(truth_arr)];
		seq_starts = np.nonzero(seq_arr & truth_arr)[0];
		seq_ends = np.nonzero(seq_arr & ~truth_arr)[0];
		if len(seq_ends) < len(seq_starts):
			seq_ends = np.r_[seq_ends, len(radar_data)-1];
		elif len(seq_starts) < len(seq_ends):
			seq_ends = seq_ends[1:];
		base_intervals = np.append([seq_starts], [seq_ends], axis=0).transpose();
		start_interval = None;
		end_interval = None;
		intervals = []
		for interval in base_intervals:
			if interval[0] == 0:
				start_interval = interval;
			elif interval[1] == len(radar_data) - 1:
				end_interval = interval;
			else:
				intervals.append(interval);
		if start_interval is not None and end_interval is not None:
			intervals.append(np.array([end_interval[0], start_interval[1]+len(radar_data)]));
			intervals = np.array(intervals, dtype=np.float64);
		else:
			intervals = base_intervals;
		intervals *= self._radar.get_degree_step();
		return intervals;
		

	
	## Gets the interval in the set of given intervals which is closest
	# to containing the given value
	#
	def _get_closest_interval(self, intervals, value):
		minDist = float('inf');
		argminDist = np.array([0,0]);

		for i in range(len(intervals)):
			interval = intervals[i];
			if interval[0] <= value and value <= interval[1]:
				return interval;
			dist = min(self._circleDist(value, interval[0], 360), self._circleDist(value, interval[1], 360));
			if dist < minDist:
				minDist = dist;
				argminDist = interval;
		return argminDist;


	## Gets the shortest distance between value1 and value2, where the
	# values represent points along the perimeter of a circle (with a
	# perimeter of circleSize). Values greater than the perimeter of the
	# circle "wrap around" so a value of 11 on a circle of perimeter 10
	# would be the same point as a value of 1 (and the distance between
	# them would be 0).
	#
	def _circleDist(self, value1, value2, circleSize):
		return np.abs((value2 - value1 + circleSize/2) % circleSize - (circleSize/2));

