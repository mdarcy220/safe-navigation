#!/usr/bin/python3


import numpy	as np
import Vector, time
from math import *
from .AbstractNavAlgo import AbstractNavigationAlgorithm
from Robot import RobotControlInput
from StaticMapper import StaticMapper


## Implementation of the Dynamic Window algorithm for robotic navigation.
#
# @see
# \ref AbstractNavAlgo.AbstractNavigationAlgorithm
#		"AbstractNavigationAlgorithm"
#
class DynamicRrtNavigationAlgorithm(AbstractNavigationAlgorithm):

	## Initializes the navigation algorithm.
	# 
	# @param sensors (dict of sensors)
	# <br>	-- the sensors that this algorithm has access to
	#
	# @param target (Target obj)
	# <br>	-- the target for the navigation
	#
	# @param cmdargs (object)
	# <br>	-- A command-line arguments object generated by `argparse`.
	# 
	def __init__(self, sensors, target, cmdargs):
		# Init basic members
		self._sensors = sensors;
		self._target  = target;
		self._cmdargs = cmdargs;

		self._radar = sensors['radar'];
		self._gps = sensors['gps'];

		self._mapper = sensors['mapper'] if 'mapper' in sensors.keys() else StaticMapper(sensors);

		self._data_size = self._radar.get_data_size();
		self._radar_range = self._radar.radius;
		self._radar_resolution = self._radar.resolution;
		self._dynamic_radar_data = self._radar.scan_dynamic_obstacles(self._gps.location());

		#Algo
		self._maxstepsize = cmdargs.robot_speed*10;
		self._maxWayPoints = 500;
		self._wayPointCache = []
		self._goalThreshold = cmdargs.robot_speed * 0.75; #In pixel distance
		self._goalBias = 0.1;
		self._wayPointBias = 0.3;
		self._maxRrtSize = 5000;
		self.debug_info = {"path": None, "point": None}

		#Make initial RRT from start to goal
		self._solution = []
		self._initRRT(self._target.position, self._gps.location(), False);
		self._grow_rrt(); 
		self._extract_solution(); 

		self._last_solution_node = Node((int(self._gps.location()[0]), int(self._gps.location()[1])))
		self._has_given_up = False


	## Next action selector method.
	#
	# @see 
	# \ref AbstractNavAlgo.AbstractNavigationAlgorithm.select_next_action
	#		"AbstractNavigationAlgorithm.select_next_action()"
	#
	def select_next_action(self):
		self._dynamic_radar_data = self._radar.scan_dynamic_obstacles(self._gps.location());

		self.debug_info['mapdata'] = self._mapper.get_grid_data();

		if self._last_solution_node.data != (int(self._gps.location()[0]), int(self._gps.location()[1])):
			self._solution.insert(0, self._last_solution_node)

		self._invalidateNodes();

		robot_location = self._gps.location()
		grid_data = self._radar._env.grid_data
		if grid_data[int(robot_location[0])][int(robot_location[1])] != 3:
			if self._solution_contains_invalid_node() or (len(self._solution) > 0 and self._collides(self._gps.location(), self._solution[0].data, False)):
				self._regrow_rrt();
				self._extract_solution();

			if len(self._solution) > 0:
				while 0 < len(self._solution) and Vector.distance_between(self._gps.location(), self._solution[0].data) < 25:
					del self._solution[0];
				if len(self._solution) > 0:
					direction = Vector.degrees_between(self._gps.location(), self._solution[0].data)
					dist = min(self._maxstepsize, Vector.distance_between(self._gps.location(), self._solution[0].data))
					self.debug_info["path"] = self._solution
					self._last_solution_node = self._solution[0]
				else:
					dist = 0;
					direction = 0;
			else:
				#No valid path found
				self._has_given_up = True
				dist = 0
				direction = np.random.uniform(low=0, high=360);

		else:
			#If robot is inside dynamic obstacle
			dist = 0
			direction = np.random.uniform(low=0, high=360);

		return RobotControlInput(dist, direction);


	def has_given_up(self):
		return self._has_given_up


	def _regrow_rrt(self):
		nearest_valid_node = self._nearest_neighbour(self._gps.location())

		self._initRRT(nearest_valid_node.data, self._gps.location(), True);
		self._grow_rrt();

	def _grow_rrt(self):
		# Always call initRRT before growRRT
		qNew = self._qstart;
		foundGoal = False;
		count = 0;

		while not foundGoal and count < self._maxRrtSize:
			qTarget = self._choose_target(); #Type Node
			qNew = self._rrt_extend(qTarget);
			if qNew is not None:
				count += 1
				if Vector.distance_between(qNew.data, self._qgoal.data) < self._goalThreshold:
					foundGoal = True

		if foundGoal:
			self._final_node = qNew
		else:
			self._final_node = None

	def _invalidateNodes(self):
		nearby_nodes = self._rrt.get_nearby_nodes(self._gps.location(), self._radar_range)
		for node in nearby_nodes:
			if node.parent and (node.flag == 0) and self._collides(node.data, node.parent.data, True):
				node.invalidate()
		self._qstart.flag = 0;


	def _initRRT(self, qstart, qgoal, append):
			self._qstart = Node(qstart);
			self._qgoal = Node(qgoal);

			if not append:
				self._rrt = Tree(self._qstart.data);

	def _solution_contains_invalid_node(self):
		for node in self._solution:
			if node.flag == 1:
				return True

		return False

	def _choose_target(self):
		randReal = np.random.uniform(0.0, 1.0);
		if len(self._wayPointCache) > 0:
				randInt = np.random.randint(0, len(self._wayPointCache) - 1);

		if randReal < self._goalBias:
			return self._qgoal;
		else:
			if randReal < (self._goalBias + self._wayPointBias) and self._wayPointCache:
				return self._wayPointCache[randInt];
			else:
				return self._get_safe_random_node();

	def _extract_solution(self):
		self._solution = []
		if self._final_node is not None:
			current_node = self._final_node; #Nearest node to the robot's current position
			i = 0;
			while current_node.data != self._target.position:
				self._solution.append(current_node.parent);
				current_node = current_node.parent;

			wayPointCacheSpaceLeft = self._maxWayPoints - len(self._wayPointCache);
			numOfSolutionNodes = len(self._solution);

			self._wayPointCache.extend(self._solution[0:wayPointCacheSpaceLeft]);
			remaining_solution_nodes = self._solution[wayPointCacheSpaceLeft:];
			solution_index = 0;
			for randIndex in np.random.randint(low=0, high=len(self._wayPointCache), size=len(remaining_solution_nodes)):
				self._wayPointCache[randIndex] = remaining_solution_nodes[solution_index];
				solution_index += 1;

			assert len(self._wayPointCache) <= self._maxWayPoints	

		else:
			#Algo ran out of max rrt size
			pass

	def _nearest_neighbour(self, qTarget):
		nearest_node = min(self._rrt.toListValidNodes(), key=lambda t: (t.data[0]-qTarget.data[0])**2 + (t.data[1]-qTarget.data[1])**2)
		return nearest_node


	# Implementation of Near() as described in:
	# Karaman and Frazzoli, "Incremental Sampling-based Algorithms
	# for Optimal Motion Planning".
	def _near(self, qTarget, n):
		tree_nodes = self._rrt.toListValidNodes()
		ZETA = np.pi  # Volume of unit ball in 2D
		GAMMA = ZETA  # A constant
		ETA = self._maxstepsize
		radius = min(((GAMMA/ZETA)*(np.log(n)/n))**2, ETA)
		return [vertex for vertex in tree_nodes if Vector.distance_between(vertex.data, qTarget.data) < radius]


	# The Steer() function referenced in RRT papers (the main component of the typical Extend() function)
	def _steer(self, p1, p2):
		dist = Vector.distance_between(p1, p2)
		if dist  < self._maxstepsize:
			return p2
		else:
			scale_factor = self._maxstepsize / dist
			return (p1[0] + (p2[0] - p1[0])*scale_factor, p1[1] + (p2[1] - p1[1])*scale_factor)

	# The Extend() function for regular RRT
	def _rrt_extend(self, qTarget):
		qNearest = self._nearest_neighbour(qTarget);
		qNew = Node(self._steer(qNearest.data, qTarget.data))
		if self._collides(qNearest.data, qNew.data, False):
			return None
		qNearest.addChild(qNew)
		return qNew

	def _get_safe_random_node(self):
		while True:
			rand_point = self._get_random_point()
			if not self._collides(None, rand_point, False):
				return Node(rand_point)

	def _collides(self, fromPoint, toPoint, dynamicOnly):
		grid_data = self._mapper.get_grid_data();#self._radar._env.grid_data

		if fromPoint is not None:
			ang_in_radians = Vector.degrees_between(fromPoint, toPoint) * np.pi / 180
			dist = Vector.distance_between(fromPoint, toPoint)

			cos_cached = np.cos(ang_in_radians)
			sin_cached = np.sin(ang_in_radians)
			for i in np.arange(0, dist, 2):
				x = int(cos_cached * i + fromPoint[0])
				y = int(sin_cached * i + fromPoint[1])
				if grid_data[x][y] & 1 and Vector.distance_between((x,y), self._gps.location()) < self._radar.radius:
					return True
				if not dynamicOnly:
					if grid_data[x][y] & 4:
						return True
		else:
			# Check for dynamic obstacle
			if grid_data[int(toPoint[0])][int(toPoint[1])] & 1 and Vector.distance_between(toPoint, self._gps.location()) < self._radar.radius:
				return True
			# Check for static obstacle
			if not dynamicOnly:
				if grid_data[int(toPoint[0])][int(toPoint[1])] & 4:
					return True;

		return False;

	def _get_random_point(self):
		XDIM = 800
		YDIM = 600
		return np.random.random() * XDIM, np.random.random() * YDIM


class Tree:

	def __init__(self, root_data):
		self.root = Node(root_data);

	def toList(self):
		return self.root.toList();

	def toDataList(self):
		return [node.data for node in self.root.toList()]

	def toListValidNodes(self):
		return [node for node in self.root.toList() if node.flag == 0]

	def toValidDataList(self):
		return [node.data for node in self.root.toList() if node.flag == 0]

	def toListInvalidNodes(self):
		return [node for node in self.root.toList() if node.flag == 1]

	def toInvalidDataList(self):
		return [node.data for node in self.root.toList() if node.flag == 1]

	def get_nearby_nodes(self, center, distance):
		return [node for node in self.toList() if Vector.distance_between(center, node.data) <= distance]

	def getSize(self):
		return self.root.size;

class Node:

	def __init__(self, data):
		self.data = tuple((int(data[0]), int(data[1])));
		self._children = [];
		self.parent = None;
		self.size = 1;
		self.flag = 0; # 0 means valid

	def addChild(self, child):
		self._children.append(child);
		child.parent = self;
		self.incrementSize();

	def toList(self):
		result = []

		frontier = Stack();
		frontier.push(self);

		for node in self._children:
			frontier.push(node)

		while True:
			if frontier.isEmpty() or len(result) == self.size:
				return result;
			else:
				currentNode = frontier.pop();
				result.append(currentNode);
				for node in currentNode._children:
					frontier.push(node);

	def toListValidChildren(self):
		result = []

		frontier = Stack();
		if self.flag == 0:
			frontier.push(self);
		else:
			return None #No valid nodes found

		for node in self._children:
			if node.flag == 0:
				frontier.push(node)

		while True:
			if len(result) == self.validSize:
				return result;
			else:
				currentNode = frontier.pop();
				result.append(currentNode);
				for node in currentNode._children:
					if node.flag == 0:
						frontier.push(node);

	def invalidate(self):
		self.flag = 1
		for child in self._children:
			child.invalidate()
		self.parent.size -= self.size;
		self._children = [];

	def validate(self):
		self.flag = 0
		if self.parent is not None:
			self.parent.validate()

	def incrementSize(self):
		self.size += 1;
		if self.parent:
			self.parent.incrementSize();


class Stack:
		"A container with a last-in-first-out (LIFO) queuing policy."
		def __init__(self):
				self.list = []

		def push(self,item):
				"Push 'item' onto the stack"
				self.list.append(item)

		def pop(self):
				"Pop the most recently pushed item from the stack"
				return self.list.pop()

		def isEmpty(self):
				"Returns true if the stack is empty"
				return len(self.list) == 0

