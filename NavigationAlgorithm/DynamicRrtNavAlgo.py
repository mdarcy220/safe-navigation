#!/usr/bin/python3


import numpy	as np
import Vector, time
from math import *
from .AbstractNavAlgo import AbstractNavigationAlgorithm
from Robot import RobotControlInput
from StaticMapper import StaticMapper
from Environment import ObsFlag


## Implementation of the Dynamic Window algorithm for robotic navigation.
#
# @see
# \ref AbstractNavAlgo.AbstractNavigationAlgorithm
#		"AbstractNavigationAlgorithm"
#
class DynamicRrtNavigationAlgorithm(AbstractNavigationAlgorithm):

	## Initializes the navigation algorithm.
	# 
	# @param sensors (dict of sensors)
	# <br>	-- the sensors that this algorithm has access to
	#
	# @param target (Target obj)
	# <br>	-- the target for the navigation
	#
	# @param cmdargs (object)
	# <br>	-- A command-line arguments object generated by `argparse`.
	# 
	def __init__(self, sensors, target, cmdargs):
		# Init basic members
		self._sensors = sensors;
		self._target  = target;
		self._cmdargs = cmdargs;

		self._radar = sensors['radar'];
		self._gps = sensors['gps'];

		self._mapper = sensors['mapper'] if 'mapper' in sensors.keys() else StaticMapper(sensors);

		self._data_size = self._radar.get_data_size();
		self._radar_range = self._radar.radius;
		self._dynamic_radar_data = self._radar.scan_dynamic_obstacles(self._gps.location());

		self._has_given_up = False

		# Algorithm parameters
		self._maxstepsize = cmdargs.robot_speed*5;
		self._maxWaypoints = 500;
		self._waypointCache = []
		self._goalThreshold = cmdargs.robot_speed * 1.5;
		self._waypoint_threshold = 25 if sensors['debug']['name'] == 'safe' else 3
		self._goalBias = 0.1;
		self._waypointBias = 0.3;
		self._maxGrowths = 3000;
		self._maxFailedGrowths = 2000;
		self.debug_info = {"path": None, "point": None}

		# Make initial RRT from start to goal
		self._solution = []
		self._initRRT(self._target.position, self._gps.location());
		self._grow_rrt(); 
		self._extract_solution(); 


	## Next action selector method.
	#
	# @see 
	# \ref AbstractNavAlgo.AbstractNavigationAlgorithm.select_next_action
	#		"AbstractNavigationAlgorithm.select_next_action()"
	#
	def select_next_action(self):
		self._mapper.add_observation();
		self.debug_info['mapdata'] = self._mapper.get_grid_data();

		self._invalidateNodes();

		robot_location = self._gps.location()
		if not (self._radar._env.get_obsflags(robot_location) & ObsFlag.DYNAMIC_OBSTACLE or self._mapper.get_grid_data()[int(robot_location[0])][int(robot_location[1])] & ObsFlag.STATIC_OBSTACLE):
			if any([n.flag == 1 for n in self._solution]) or (len(self._solution) > 0 and self._collides(robot_location, self._solution[0].data)):
				self._regrow_rrt();
				self._extract_solution();

			while 0 < len(self._solution) and Vector.distance_between(robot_location, self._solution[0].data) < self._waypoint_threshold:
				del self._solution[0];

			if len(self._solution) > 0:
				direction = Vector.degrees_between(robot_location, self._solution[0].data)
				dist = min(self._maxstepsize, Vector.distance_between(robot_location, self._solution[0].data))
				self.debug_info["path"] = self._solution
			else:
				#No valid path found
				self._has_given_up = True
				dist = 0
				direction = np.random.uniform(low=0, high=360);
		elif self._mapper.get_grid_data()[int(robot_location[0])][int(robot_location[1])] & ObsFlag.STATIC_OBSTACLE:
			self._has_given_up = True
			dist = 0
			direction = np.random.uniform(low=0, high=360);
		else:
			#If robot is inside dynamic obstacle
			dist = 0
			direction = np.random.uniform(low=0, high=360);
		self.debug_info['rrt_tree'] = self._rrt
		return RobotControlInput(dist, direction);


	def has_given_up(self):
		return self._has_given_up


	def _regrow_rrt(self):
		self._qgoal = Node(self._gps.location())
		self._grow_rrt();

	def _grow_rrt(self):
		foundGoal = False;
		successfulGrowths = 0;
		failedGrowths = 0;
		self._final_node = None

		while successfulGrowths < self._maxGrowths and failedGrowths < self._maxFailedGrowths and not foundGoal:
			qNew = self._rrt_extend(self._choose_target())
			if qNew is None:
				failedGrowths += 1;
				continue;

			# We only care about consecutive failed growths
			failedGrowths = 0;

			successfulGrowths += 1;
			if Vector.distance_between(qNew.data, self._qgoal.data) < self._goalThreshold:
				foundGoal = True
				self._final_node = qNew

		#self._postprocess(self._final_node);


	## Post-process (smooth) the path from start_node to the root
	def _postprocess(self, start_node):
		if start_node is None:
			return;

		qDescendant = start_node
		qAncestor = qDescendant.parent
		while qDescendant is not None and qDescendant.parent is not None:
			# Check if there are any shorter paths we can take to the current node
			# but to save time only check for paths originating from the current
			# solution path
			bestAncestor = None
			while qAncestor is not None:
				if not self._collides(qDescendant.data, qAncestor.data):
					bestAncestor = qAncestor
				qAncestor = qAncestor.parent

			# Rewire the tree to take the better path
			if bestAncestor is not None:
				qDescendant.parent.removeChild(qDescendant)
				bestAncestor.addChild(qDescendant)

			qDescendant = qDescendant.parent # The parent of the old qDescendant (the current bestAncestor)
			qAncestor = qDescendant.parent   # The parent of the parent of the old qDescendant


	def _invalidateNodes(self):
		nearby_nodes = self._rrt.get_nearby_nodes(self._gps.location(), self._radar_range)
		# Add solution nodes to be checked (note: this may double-add some nodes unintentionally, but was easier to implement)
		if len(self._solution) > 0:
			nearby_nodes.extend(self._solution)
			nearby_nodes.extend(self._solution[0]._children)
		for node in nearby_nodes:
			if node.parent and (node.flag == 0) and self._collides(node.data, node.parent.data):
				node.invalidate()
		self._qstart.flag = 0;


	def _initRRT(self, qstart, qgoal):
			self._qstart = Node(qstart);
			self._qgoal = Node(qgoal);
			self._rrt = Tree(self._qstart.data);

	def _choose_target(self):
		randReal = np.random.uniform(0.0, 1.0);

		if randReal < self._goalBias:
			return self._qgoal;
		elif randReal < (self._goalBias + self._waypointBias) and self._waypointCache and (len(self._waypointCache) > 0):
			randInt = np.random.randint(0, len(self._waypointCache));
			return self._waypointCache[randInt];
		else:
			XDIM = 800
			YDIM = 600
			return Node((np.random.uniform(low=0.0, high=XDIM), np.random.uniform(low=0.0, high=YDIM)))


	def _extract_solution(self):
		self._solution = []
		if self._final_node is None:
			return
		current_node = self._final_node; # Nearest node to the robot's current position
		i = 0;
		while current_node.parent is not None:
			self._solution.append(current_node.parent);
			current_node = current_node.parent;

		waypointCacheSpaceLeft = self._maxWaypoints - len(self._waypointCache);
		numOfSolutionNodes = len(self._solution);

		self._waypointCache.extend(self._solution[0:waypointCacheSpaceLeft]);
		remaining_solution_nodes = self._solution[waypointCacheSpaceLeft:];
		solution_index = 0;
		for randIndex in np.random.randint(low=0, high=len(self._waypointCache), size=len(remaining_solution_nodes)):
			self._waypointCache[randIndex] = remaining_solution_nodes[solution_index];
			solution_index += 1;

		assert len(self._waypointCache) <= self._maxWaypoints

	def _nearest_neighbour(self, qTarget):
		nodes = self._rrt.toListValidNodes();
		if len(nodes) == 0:
			return None
		return min(nodes, key=lambda t: (t.data[0]-qTarget.data[0])**2 + (t.data[1]-qTarget.data[1])**2)


	## Implementation of Near() as described in:
	# Karaman and Frazzoli, "Incremental Sampling-based Algorithms
	# for Optimal Motion Planning".
	def _near(self, qTarget, n):
		tree_nodes = self._rrt.toListValidNodes()
		ZETA = np.pi       # Volume of unit ball in 2D
		GAMMA = 800*600*6  # A constant: 2^d (1 + 1/d) mu_L(X_free)
		ETA = self._maxstepsize*5
		radius = min(((GAMMA/ZETA)*(np.log(n)/n))**2, ETA)
		return [vertex for vertex in tree_nodes if Vector.distance_between(vertex.data, qTarget.data) < radius]


	## The Steer() function referenced in RRT papers (the main component of the typical Extend() function)
	def _steer(self, p1, p2):
		dist = Vector.distance_between(p1, p2)
		if dist  < self._maxstepsize:
			return p2
		scale_factor = self._maxstepsize / dist
		return (p1[0] + (p2[0] - p1[0])*scale_factor, p1[1] + (p2[1] - p1[1])*scale_factor)

	## The Extend() function for regular RRT
	def _rrt_extend(self, qTarget):
		qNearest = self._nearest_neighbour(qTarget);
		if qNearest is None:
			return None

		qNew = Node(self._steer(qNearest.data, qTarget.data))
		if self._collides(qNearest.data, qNew.data):
			return None
		qNearest.addChild(qNew)
		return qNew

	## The Extend() function for RRT*, as described in:
	# Karaman and Frazzoli, "Incremental Sampling-based Algorithms
	# for Optimal Motion Planning".
	def _rrtstar_extend(self, qTarget):
		qNearest = self._nearest_neighbour(qTarget);
		qNew = Node(self._steer(qNearest.data, qTarget.data))
		if self._collides(qNearest.data, qNew.data):
			return None
		qMin = qNearest
		nearby_points = self._near(qNew, self._rrt.root.size)
		for qNear in nearby_points:
			if not self._collides(qNear.data, qNew.data):
				c = self._cost(qNear) + Vector.distance_between(qNear.data, qNew.data)
				if c < self._cost(qNew):
					qMin = qNear
		qMin.addChild(qNew)
		for qNear in nearby_points:
			if self._cost(qNear) > (self._cost(qNew) + Vector.distance_between(qNew.data, qNear.data)) and not self._collides(qNew.data, qNear.data):
				qParent = qNear.parent
				qParent.removeChild(qNear)
				qNew.addChild(qNear)
		return qNew

	def _cost(self, node):
		total_cost = 0
		qChild = node
		qParent = qChild.parent
		while qParent is not None:
			total_cost += Vector.distance_between(qParent.data, qChild.data)
			qChild = qParent
			qParent = qChild.parent
		return total_cost


	def _collides(self, fromPoint, toPoint):
		grid_data = self._mapper.get_grid_data();

		if fromPoint is not None:
			ang_in_radians = Vector.degrees_between(fromPoint, toPoint) * np.pi / 180
			dist = Vector.distance_between(fromPoint, toPoint)

			cos_cached = np.cos(ang_in_radians)
			sin_cached = np.sin(ang_in_radians)
			for i in np.arange(0, dist, 1):
				x = int(cos_cached * i + fromPoint[0])
				y = int(sin_cached * i + fromPoint[1])
				if grid_data[x,y] & ObsFlag.ANY_OBSTACLE:
					return True
				if self._sensors['debug']['name'] != 'safe' and self._radar._env.get_obsflags([x,y]) & ObsFlag.DYNAMIC_OBSTACLE and Vector.distance_between(np.array([x,y]), self._gps.location()) < self._radar.radius:
					return True

		return grid_data[int(toPoint[0])][int(toPoint[1])] & ObsFlag.ANY_OBSTACLE;


class Tree:

	def __init__(self, root_data):
		self.root = Node(root_data);

	def toList(self):
		return self.root.toList();

	def toListValidNodes(self):
		return [node for node in self.root.toList() if node.flag == 0]

	def get_nearby_nodes(self, center, distance):
		return [node for node in self.toList() if Vector.distance_between(center, node.data) <= distance]

	def getSize(self):
		return self.root.size;

class Node:

	VALID = 0
	INVALID = 1

	def __init__(self, data):
		self.data = tuple((int(data[0]), int(data[1])));
		self._children = [];
		self.parent = None;
		self.size = 1;
		self.flag = Node.VALID;

	def addChild(self, child):
		self._children.append(child);
		child.parent = self;
		self.incrementSize(child.size);

	def removeChild(self, child):
		self._children.remove(child);
		child.parent = None
		self.decrementSize(child.size);

	def toList(self):
		result = [self]
		for child in self._children:
			result += child.toList()
		return result

	def invalidate(self):
		self.flag = Node.INVALID
		for child in self._children:
			child.invalidate()
		self.parent.size -= self.size;
		self._children = [];

	def validate(self):
		self.flag = Node.VALID
		if self.parent is not None:
			self.parent.validate()

	def incrementSize(self, size=1):
		self.size += size;
		if self.parent:
			self.parent.incrementSize(size);

	def decrementSize(self, size=1):
		self.size -= size;
		if self.parent:
			self.parent.decrementSize(size);

